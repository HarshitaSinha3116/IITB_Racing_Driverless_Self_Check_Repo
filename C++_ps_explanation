#include <ncurses.h> //includes the ncurses library to control terminal screen, input-output
#include <unistd.h> //includes functions t delay execution
#include <vector> //rom stl
#include <cstdlib> // to get functions like rand() and srand()
#include <ctime> 
#include <algorithm>//provides functions which if were not there then we would have to code ourselves like find(), sort()

using namespace std;

// Directions 
enum Direction { UP, DOWN, LEFT, RIGHT };//enum is used to define the constant possible movement direction

// ---------------- Snake ---------------- WE MAKE THE FIRST CLASS SNAKE.........(1)
class Snake { 
private: 
vector<pair<int,int>> body; // (y, x) // create a vector to store the x,y coordinates of the snake
Direction dir;//dir from Direction class(enum) used to store the current direction of the snake

public: 
Snake(int startY, int startX) { // making a constructor that is used to initialise the current position of the snake
body.push_back({startY, startX}); //adds the head segment
body.push_back({startY, startX - 1});// adds the second segment to the left
body.push_back({startY, startX - 2});//adds the third segment to he left
//from this the snake moves to the left
dir = RIGHT;//initial direction is right
}

void setDirection(Direction d) {//define a member function to change the direction of the snake based on the relation b/w dir and d
    // Prevent reversing direction
    if ((dir == UP && d == DOWN) || (dir == DOWN && d == UP) ||//checks for reverse direction vertically
        (dir == LEFT && d == RIGHT) || (dir == RIGHT && d == LEFT))//checks for reverse direction horizontally
        return;// to ignore the irrelevant reverse moves
    dir = d;//except the reverse case updates the direction
}

pair<int,int> getHead() const {//returns the coord of the head
    return body.front();//returs the first element of the vector body
}

const vector<pair<int,int>>& getBody() const {//returns reference to snake body
    return body;//returns the vector
}

void move(bool grow = false) {//a member function to move the snake
    pair<int,int> head = body.front();//copies the current head

    switch (dir) {//using the swtch statement to check the current  of the snake
        case UP:    head.first--; break;//actions according to diff directions, like when dir = up: move the coord to up
        case DOWN:  head.first++; break;
        case LEFT:  head.second--; break;
        case RIGHT: head.second++; break;
    }

    body.insert(body.begin(), head);//adds new heads at front
    if (!grow) body.pop_back();//removes tail unless the snake's body is growing
}

bool selfCollision() const {//member function which checks onto the collision of the snake with itself
    pair<int,int> head = body.front();//getting the coord of the head
    for (size_t i = 1; i < body.size(); i++) {//to check whether any part of the body collides with the head or not....if collides then coord of that part and that of head becomes same
        if (body[i] == head) return true;
    }
    return false;
}

};

// ---------------- Food ---------------- 
class Food {//starts food class
private: 
int y, x;//represents food's position

public: 
Food() : y(0), x(0) {}//constructor: initialises food's coord

void spawn(int height, int width, const vector<pair<int,int>>& snakeBody) {//uses rand() function to place the food at any random coord
    while (true) {
        y = rand() % (height - 2) + 1;//random y inside the border
        x = rand() % (width - 2) + 1;//eandom x inside the border

        if (find(snakeBody.begin(), snakeBody.end(), make_pair(y, x)) == snakeBody.end())//compares the coord of the food the that if the snake
            break;//make_pair() is a std function used to create an object of type int....this if used so that we can compare both x and y together
    }
}

int getY() const { return y; }//returns the x and y coord
int getX() const { return x; }

};

// ---------------- Game ---------------- 
class Game { //
private: 
int height, width;//screen;s dimensions
int score;
bool gameOver;//state of the game

Snake snake;//instance attribute of class snake
Food food;//instance attribute of the class food

public: 
Game(int h, int w) : height(h), width(w), score(0), gameOver(false), snake(h/2, w/2) { //constructor used for initiallisation
food.spawn(height, width, snake.getBody());//spawns food
}

void drawBorder() {//member function to draw the border
    for (int x = 0; x < width; x++) {
        mvprintw(0, x, "#");//a ncurses function: used to move the cursor to a specific position on the terminal and print whatever is to be printed there
        mvprintw(height-1, x, "#"); its format is mvprintw(int y, int x, const char "tpo be printed")
    }//for loops to make border along both x and y axis
    for (int y = 0; y < height; y++) {
        mvprintw(y, 0, "#");
        mvprintw(y, width-1, "#");
    }
}

void handleInput() {//member function used to read input from the key board
    int ch = getch();//a function from ncurses that reads a single key press from the keyboard
    switch (ch) {//using the switch statement
        case KEY_UP:
        case 'w': snake.setDirection(UP); break;
        case KEY_DOWN:
        case 's': snake.setDirection(DOWN); break;
        case KEY_LEFT:
        case 'a': snake.setDirection(LEFT); break;
        case KEY_RIGHT:
        case 'd': snake.setDirection(RIGHT); break;
        default: break;
    }
}

void update() {//member function to update the games logic
    pair<int,int> head = snake.getHead();//find the coord of head
    bool grow = false;

    // Check food collision
    if (head.first == food.getY() && head.second == food.getX()) {//check if food is eaten or not
        score += 10;
        grow = true;
        food.spawn(height, width, snake.getBody());//spawn new food
    }

    snake.move(grow);//move the snake
    head = snake.getHead();//update the coord of the head

    // Wall collision
    if (head.first <= 0 || head.first >= height-1 ||//collision with vertical wall
        head.second <= 0 || head.second >= width-1) {//collision with the horizontal wall
        gameOver = true;// if collision occured then game is over
    }

    // Self collision
    if (snake.selfCollision()) {
        gameOver = true;if collision occured with itself then game is over
    }
}

void draw() {// member function to draw the frame
    clear();//clear the screen
    drawBorder();

    // Draw snake
    for (auto &p : snake.getBody()) {//iterate the sanke
        mvprintw(p.first, p.second, "O");// draw the snakes body
    }

    // Draw food
    mvprintw(food.getY(), food.getX(), "*");

    mvprintw(height, 2, "Score: %d", score);//craw the score
    refresh();//update the terminal
}

void gameOverScreen() {//member function to end the game
    clear();
    mvprintw(height/2 - 1, width/2 - 5, "GAME OVER");
    mvprintw(height/2, width/2 - 7, "Final Score: %d", score);
    mvprintw(height/2 + 2, width/2 - 14, "Press R to Restart or Q to Quit");
    refresh();

    nodelay(stdscr, FALSE);//a function from ncurses that controls whether input ncurses functions like getch() should wait for user's input or not
    //syntax = int nodelay(win, bf)// win: the window whose input mode is to be changed (here srdscr means the main screen) and bf means boolean flag (TRUE/FALSE)
    while (true) {
        int ch = getch();//reading the keys
        if (ch == 'q' || ch == 'Q') break;
        if (ch == 'r' || ch == 'R') {
            score = 0;//restart
            gameOver = false;
            snake = Snake(height/2, width/2);
            food.spawn(height, width, snake.getBody());
            nodelay(stdscr, TRUE);
            run();//restart the game
            return;
        }
    }
}

void run() {//member function to run the game
    while (!gameOver) {
        handleInput();
        update();
        draw();
        usleep(120000);//delay
    }
    gameOverScreen();
}

};

// ---------------- main ---------------- 
int main() { 
srand(time(NULL));// a function which seeds the random number generator using the current time
initscr();//INITIALIZES THE NCURSES SYSTEM
noecho();//when you press the keys they will not be printed on the screen but still be implemented
curs_set(0);//hides the blinking curser
keypad(stdscr, TRUE);//enable the special keys like the arrow keys for the main screen 
nodelay(stdscr, TRUE);

int height = 25;
int width = 60;

Game game(height, width);
game.run();

endwin();// ends the ncurses mode and restores the normal terminal
return 0;

}
